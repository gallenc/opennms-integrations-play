/*******************************************************************************
 * This file is part of OpenNMS(R).
 *
 * Copyright (C) 2019 The OpenNMS Group, Inc.
 * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.
 *
 * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.
 *
 * OpenNMS(R) is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License,
 * or (at your option) any later version.
 *
 * OpenNMS(R) is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with OpenNMS(R).  If not, see:
 *      http://www.gnu.org/licenses/
 *
 * For more information contact:
 *     OpenNMS(R) Licensing <license@opennms.org>
 *     http://www.opennms.org/
 *     http://www.opennms.com/
 *******************************************************************************/

package org.opennms.netmgt.alarmd.drools;

import java.util.Date;
import org.kie.api.time.SessionClock;
import org.opennms.netmgt.model.OnmsAlarm;
import org.opennms.netmgt.model.OnmsSeverity;
import org.opennms.netmgt.model.TroubleTicketState;

import org.opennms.netmgt.model.events.EventBuilder;
import org.opennms.netmgt.xml.event.AlarmData;
import org.opennms.netmgt.alarmd.drools.AlarmService;
import org.opennms.netmgt.model.OnmsEventParameter;
import org.opennms.netmgt.model.OnmsMetaData;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.ByteArrayInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;

global org.opennms.netmgt.alarmd.drools.AlarmService alarmService;

declare org.opennms.netmgt.model.OnmsAlarm
    @role(event)
    @timestamp(lastUpdateTime)
end

declare URIMapping
	category : String
	uei : String
	severity : String
end

declare UeiMap

  // category, uei, severity
  // Map<String, Map<String, String>> ueimap = new HashMap();
  ueimap : Map
end

rule "read and insert config file"   
    when
        eval( 1==1 )
    then

        List<URIMapping> ueimapping = readMappingFile(alarmService);
        
        Map ueimap =  mappingToFactConstant(alarmService, ueimapping);
        
        displayUeiFacts(alarmService, ueimap);
                
        UeiMap ueiMap = new UeiMap();
        ueiMap.setUeimap(ueimap);

        insert ( ueiMap );
     
        alarmService.warn( "inserted uei map" );
end

rule "change alarm priority"
  when
    $sessionClock : SessionClock()
    $UeiMap : UeiMap() 
    
    // get alarms which match the uei's in groupMap
    $alarm : OnmsAlarm(alarmType == OnmsAlarm.PROBLEM_TYPE,
                       node != null,
                       lastEvent != null,
                       
                       // metadata cant work because lazy loading and alarm is not in a transaction
                       $UeiMap.ueimap.keySet() contains $VALUE : node.findMetaDataForContextAndKey("context", "key").orElse(new OnmsMetaData("", "", "DEFAULT")).getValue()
                      
                     // $UeiMap.ueimap.keySet() contains $VALUE : node.getCategories()
                      
                      
                      // $maps : HashMap() from $UeiMap.ueimap.get($VALUE),
                     // $maps : HashMap(),
                     //  $severity :  $maps.get(lastEvent.eventUei)
                      )
     // see https://stackoverflow.com/questions/58257679/variables-can-not-be-used-inside-bindings                 
     $mapping : Map() from $UeiMap.ueimap.get($VALUE)
     
     $newseverity: String() from $mapping.get($alarm.lastEvent.eventUei)
    
                      
   then
    Date now = new Date(drools.getWorkingMemory().getSessionClock().getCurrentTime());
    
  //  String newseverity = $UeiMap.ueimap.get($VALUE).get($alarm.lastEvent.eventUei);
    
    // debugging messages - note change to alarmService.debug in production
    alarmService.warn("applied new severity {}: matched alarm {}",  $newseverity, $alarm);

end


function displayUeiFacts(AlarmService alarmService, Map dataIn) {

		Map<String, Map<String, String>> data = (Map<String, Map<String, String>>) dataIn;
		StringBuilder sb = new StringBuilder();
		for (String category : data.keySet()) {
			Map<String, String> ueimap = data.get(category);
			for (String uei : ueimap.keySet()) {
				String severity = ueimap.get(uei);
				sb.append("keymapentry: " + " category: " + category + " uei: " + uei + " severity: " + severity+"\n");
			}
		}
		
		alarmService.warn("Loaded uei map data:\n"+sb.toString());
		
}

function  Map<String, Map<String, String>> mappingToFactConstant(AlarmService alarmService, List ueiMap) {

        List<URIMapping> ueiMapping = (List<URIMapping>) ueiMap;

		// category, uei, severity
		Map<String, Map<String, String>> ueimap = new HashMap();

		for (URIMapping mapping : ueiMapping) {
			String category = mapping.getCategory();
			String uei = mapping.getUei();
			String severity = mapping.getSeverity();

			if (!ueimap.containsKey(category))
				ueimap.put(category, new HashMap<String, String>());

			Map<String, String> ueiseverity = ueimap.get(category);
			ueiseverity.put(uei, severity);

		}

		return ueimap;

	}
	

function List<URIMapping> readMappingFile(AlarmService alarmService) {
		String home = System.getProperty("opennms.home");

		File ruleConstantsFile = new File(home + "/etc/alarmd/rules-constants.csv");
		alarmService.warn("Reading ruleConstantsFile :" + ruleConstantsFile.getAbsolutePath()+"  File exists " + ruleConstantsFile.exists());

		List<URIMapping> mappingList = new ArrayList<URIMapping>();

		Scanner scanner = null;
		if (ruleConstantsFile.exists())
			try {

				FileInputStream ruleConstantsStream = new FileInputStream(ruleConstantsFile);
				mappingList = readMappingStream(alarmService, ruleConstantsStream);

			} catch (Exception e) {
				e.printStackTrace();
			} finally {
				if (scanner != null)
					scanner.close();
			}

		return mappingList;

}

function List<URIMapping> readMappingCSVString(AlarmService alarmService, String csvString) {
		InputStream ruleConstantsStream = new ByteArrayInputStream(csvString.getBytes(Charset.forName("UTF-8")));
		return readMappingStream(alarmService, ruleConstantsStream);
}


function List<URIMapping> readMappingStream(AlarmService alarmService, InputStream ruleConstantsStream) {
		List<URIMapping> mappingList = new ArrayList<URIMapping>();

		Scanner scanner = null;
		try {
			scanner = new Scanner(ruleConstantsStream);

			while (scanner.hasNext()) {
				String data = scanner.next();
				String[] parts = data.split(",");
				if (parts.length == 3) {
					URIMapping u = new URIMapping();
					u.setCategory(parts[0].trim());
					u.setUei(parts[1].trim());
					u.setSeverity(parts[2].trim());
					mappingList.add(u);
				}
			}

		} catch (Exception e) {
			alarmService.warn(e.getMessage());
			e.printStackTrace();
		} finally {
			if (scanner != null)
				scanner.close();
		}

		return mappingList;

}


function void writeMappingFile(AlarmService alarmService, List ueiMappings) {

		String home = System.getProperty("opennms.home");

		File ruleConstantsFile = new File(home + "/etc/alarmd/rules-constants.csv");

		alarmService.warn("writing ruleConstantsFile :" + ruleConstantsFile.getAbsolutePath());

		FileWriter fileWriter = null;
		try {
			ruleConstantsFile.delete();
			ruleConstantsFile.createNewFile();
			fileWriter = new FileWriter(ruleConstantsFile);
			for (Object u : ueiMappings) {
				URIMapping umap = (URIMapping) u;
				StringBuilder line = new StringBuilder();
				line.append(umap.getCategory()).append(",").append(umap.getUei()).append(",").append(umap.getSeverity()).append("\n");
				String s = line.toString();
				fileWriter.write(s);
				alarmService.warn("  mapping:"+s);
			}
		} catch (Exception e) {
			alarmService.warn("cannot write file:", e);

		} finally {
			if (fileWriter != null)
				try {
					fileWriter.close();
				} catch (IOException e) {
				}
		}
}


        
